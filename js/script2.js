// Задача 7
// Функция должна проверять, name является ли контакт реальным firstName и данное свойство ( prop)
// является свойством этого контакта.
// const contacts = [
//   {
//     firstName: "Akira",
//     lastName: "Laine",
//     number: "0543236543",
//     likes: ["Pizza", "Coding", "Brownie Points"],
//   },
//   {
//     firstName: "Harry",
//     lastName: "Potter",
//     number: "0994372684",
//     likes: ["Hogwarts", "Magic", "Hagrid"],
//   },
//   {
//     firstName: "Sherlock",
//     lastName: "Holmes",
//     number: "0487345643",
//     likes: ["Intriguing Cases", "Violin"],
//   },
//   {
//     firstName: "Kristian",
//     lastName: "Vos",
//     number: "unknown",
//     likes: ["JavaScript", "Gaming", "Foxes"],
//   },
// ];
// function lookUpProfile(name, prop) {
//   // Only change code below this line
//   for (let contact of contacts) {
//     if (contact.firstName === name) {
//       if (contact.hasOwnProperty(prop)) {
//         return contact[prop];
//       } else {
//         return "No such property";
//       }
//     }
//   }
//   return "No such contact";
//   // Only change code above this line
// }
// console.log(lookUpProfile("Sherlock", "likes"));
// Задача 8
// Используйте функцию parseInt с основанием
// Функция parseInt()анализирует строку и возвращает целое число.
// Он принимает второй аргумент для системы счисления, который указывает основание числа в строке.
// Основание может быть целым числом от 2 до 36.
// Вызов функции выглядит так:
// parseInt(string, radix);
// И вот пример:
// const a = parseInt("11", 2);
// Переменная системы счисления говорит, что 11она находится в двоичной системе или с основанием 2.
// В этом примере строка преобразуется 11в целое число 3.
// Используйте parseInt()в convertToIntegerфункции,
// чтобы она преобразовывала двоичное число в целое и возвращала его.
// function convertToInteger(str) {
//   return parseInt(str, 2);
// }
// convertToInteger("10011");
// Задача 9
// несколько тернарных операторов
// В checkSignфункции используйте несколько условных операторов —
// в соответствии с рекомендуемым форматом, используемым в findGreaterOrEqual— чтобы проверить,
// является ли число положительным, отрицательным или нулем.
// Функция должна вернуть positive, negativeили zero.
// function checkSign(num) {
//   return num > 0 ? "positive" : num < 0 ? "negative" : "zero";
// }
// checkSign(10);
// Задача 10
// Замена циклов с помощью рекурсии
// Рекурсия — это концепция, согласно которой функция может быть выражена через саму себя.
// Напишите рекурсивную функцию, sum(arr, n)которая возвращает сумму первых nэлементов массива arr.
// function sum(arr, n) {
//   // Only change code below this line
//   if (n <= 0) {
//     return 0;
//   } else {
//     return sum(arr, n - 1) + arr[n - 1];
//   }
//   // Only change code above this line
// }
// Задача 11
// Используйте рекурсию для создания обратного отсчета
// Базовый вариант .
// Базовый случай сообщает рекурсивной функции, когда ей больше не нужно вызывать себя.
// Это простой случай, когда возвращаемое значение уже известно.
// Также будет рекурсивный вызов , который выполняет исходную функцию с другими аргументами.
// Если функция написана правильно, в конечном итоге будет достигнут базовый случай.
// Мы определили функцию, вызываемую countdownс одним параметром ( n).
// Функция должна использовать рекурсию для возврата массива, содержащего целые числа ,
// n на 1 основе параметра. Если функция вызывается с числом меньше 1,
// функция должна вернуть пустой массив. Например, вызов этой функции n = 5 должен вернуть
// массив [5, 4, 3, 2, 1]. Ваша функция должна использовать рекурсию, вызывая саму себя,
// и не должна использовать циклы любого вида.
// function countdown(n) {
//   if (n < 1) {
//     return [];
//   } else {
//     const arr = countdown(n - 1);
//     arr.unshift(n);
//     return arr;
//   }
// }
// console.log(countdown(10)); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
// Задача 12
// Используйте рекурсию для создания диапазона чисел
// Продолжая предыдущую задачу, мы предоставляем вам еще одну возможность создать рекурсивную функцию для решения проблемы.
// Мы определили функцию с именем rangeOfNumbersс двумя параметрами.
// Функция должна возвращать массив целых чисел, который начинается с числа,
// представленного startNumпараметром, и заканчивается числом, представленным endNumпараметром.
// Начальное число всегда будет меньше или равно конечному числу.
// Ваша функция должна использовать рекурсию, вызывая саму себя,
// и не использовать циклы любого вида.
// Это также должно работать для случаев, когда оба startNumи endNumодинаковы.
// function rangeOfNumbers(startNum, endNum) {
//   if (startNum === endNum) {
//     return [startNum];
//   } else {
//     const arr = rangeOfNumbers(startNum, endNum - 1);
//     arr.push(endNum);
//     return arr;
//   }
// }
// console.log(rangeOfNumbers(1, 5)); // [1, 2, 3, 4, 5]
// Задача 13
// Сравните области действия переменной и пусть ключевые слова
// Напишите код так, чтобы i объявленная в if операторе переменная была отдельной от
// i объявленной в первой строке функции. Убедитесь, что var ключевое слово нигде в вашем коде не используется.
// Это упражнение предназначено для того, чтобы проиллюстрировать разницу между тем,
// как ключевые слова varи letназначают область действия объявленной переменной.
// При программировании функции, подобной той, что используется в этом упражнении,
// часто лучше использовать разные имена переменных, чтобы избежать путаницы.
// Переменная i, объявленная в ifоператоре, должна равняться строке block scope.
// checkScope()должен вернуть строкуfunction scope
// function checkScope() {
//   let i = "function scope"; // i глоабльная переменная
//   if (true) {
//     let i = "block scope"; // i локальная переменная
//     console.log("Block scope i is: ", i); // block scope
//   }
//   return i; // function scope
// }
// задача 14
// Используйте параметр Rest с параметрами функции
// функция sumмогла принимать любое количество аргументов и возвращать их сумму.
// const sum = (...args) => {
//   return args.reduce((a, b) => a + b, 0);
// };
// console.log(sum(1, 2, 3)); // 6
// Задача 15
// деструктурирования с параметром Rest для переназначения элементов массива
// Результат аналогичен Array.prototype.slice(), как показано ниже:
// const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
// console.log(a, b);
// console.log(arr);
// Консоль отобразит значения 1, 2и [3, 4, 5, 7].
// Переменные aи bпринимают первое и второе значения из массива.
// После этого из-за наличия параметра rest arrполучает остальные значения в виде массива.
// Остальной элемент корректно работает только как последняя переменная в списке.
// Например, вы не можете использовать параметр rest для захвата подмассива,
// в котором отсутствует последний элемент исходного массива.
// Используйте присваивание деструктурирования с параметром rest,
// чтобы выполнить эффективный Array.prototype.slice()так, чтобы arr
// это был подмассив исходного массива sourceс опущенными первыми двумя элементами.
// const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// function removeFirstTwo(list) {
//   const [, , ...arr] = list; // Change this line
//   return arr;
// }
// const arr = removeFirstTwo(source);
// Задача 16
// Создание строк с использованием шаблонных литералов
// li Используйте литеральный синтаксис шаблона с обратными кавычками
// для создания массива строк элемента списка ( ).
// Текст каждого элемента списка должен быть одним из элементов массива из
// failure свойства resultобъекта и иметь classатрибут со значением text-warning.
// Функция makeListдолжна возвращать массив строк элементов списка.
// Используйте метод итератора (любой цикл), чтобы получить желаемый результат (показан ниже).
// [
//   '<li class="text-warning">no-var</li>',
//   '<li class="text-warning">var-on-top</li>',
//   '<li class="text-warning">linebreak</li>'
// ]
// const result = {
//   success: ["max-length", "no-amd", "prefer-arrow-functions"],
//   failure: ["no-var", "var-on-top", "linebreak"],
//   skipped: ["no-extra-semi", "no-dup-keys"],
// };
// function makeList(arr) {
//   const failureItems = [];
//   // перебираем массив
//   for (let i = 0; i < arr.length; i++) {
//     // создаем элемент списка
//     failureItems.push(`<li class="text-warning">${arr[i]}</li>`);
//   }
//   return failureItems;
// }
// const failuresList = makeList(result.failure);
// console.log(failuresList);
